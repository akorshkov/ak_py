"""Http requests library."""

import threading
import random
import string
import logging

import urllib
import urllib.request
import urllib.error
from urllib.parse import urlencode
import ssl
import json


logger = logging.getLogger(__name__)


class HttpConn:
    """Allowes to make http(s) requests."""

    def __init__(self, address,
                 *, _send_request_ids=True, processors=None):
        self.address = address
        self.processors = processors or []

        self._reqid_generator_guard = threading.Lock()
        self._reqid_connection_part = "".join(
            random.choice(string.hexdigits.lower()) for _ in range(4))
        self._cur_req_id = 0 if _send_request_ids else None

        is_https = address.lower().startswith("https://")
        self.opener = self._make_opener(is_https)

    @staticmethod
    def _make_opener(is_https, if_http_debug=False):
        # if_http_debug - make library print raw http data
        #                 printed data may contain more accurate data than what
        #                 gets into logs, but it is printed to stdout, so
        #                 it's difficult to use.
        debuglevel = 1 if if_http_debug else 0
        if is_https:
            ctx = ssl.create_default_context()
            ctx.check_hostname = False
            ctx.verify_mode = ssl.CERT_NONE
            http_handler = urllib.request.HTTPSHandler(
                context=ctx, debuglevel=debuglevel)
        else:
            http_handler = urllib.request.HTTPHandler(debuglevel=debuglevel)
        return urllib.request.build_opener(http_handler)

    def do_request(self, path, method=None, *,
                   params=None, data=None, headers=None, raw_response=False):
        """Make specified https(s) request.

        Arguments:
        - path: request path
        - method: request method. By default is "GET" or "POST" if 'data' provided
        - params: dictionary of request parameters
        - data: data for request. Can be bytes, string or any python object, which
            can be dumped to json.
        - headers: dict, explicit header for request
        - raw_response: specifies how response is handled.
            False - (default) method expects that response contains a valid
               json and returns decoded json. Exception is thrown if
               request was not successful.
            True - urllib Response object is returned "as-is".
        """

        # 1. params
        if params:
            path += "?" + urlencode(params)
        url = self.address + path

        # 2. headers
        req_headers = {} if not headers else headers.copy()
        if self._cur_req_id is not None:  # means req_id should be autogenerated if not specified
            if 'X-Request-ID' not in req_headers:
                req_headers['X-Request-ID'] = self._generate_request_id()

        # 3. method (autodetect)
        if not method:
            method = 'POST' if data else 'GET'
        else:
            method = method.upper()

        # 4. data
        if data is None:
            req_data = None
        elif isinstance(data, bytes):
            req_data = data
        else:
            str_data = data if isinstance(data, str) else json.dumps(data)
            req_data = str_data.encode(encoding='utf-8')

        request = urllib.request.Request(
            url,
            data=req_data,
            method=method,
            headers=req_headers)

        # custom pre-process request. (f.e. add auth headers)
        for processor in self.processors:
            processor.process_request(request)

        # log request.
        # !request is not final yet, urllib may add some headers during the call!
        self._log_request(request)

        # actual call
        try:
            response = self.opener.open(request)
            is_error = False
        except urllib.error.HTTPError as err:
            if not raw_response:
                raise
            response = err
            is_error = True

        with response:
            response.data = response.read()

        self._log_response(response, url)

        if not raw_response and not is_error and response.data:
            ret_val = json.loads(response.data.decode('utf-8'))
        else:
            ret_val = response

        # process return value
        for processor in self.processors[::-1]:
            ret_val = processor.process_response(ret_val, is_error)

        return ret_val

    def _generate_request_id(self):
        # generate request id
        with self._reqid_generator_guard:
            next_req_id = self._cur_req_id
            self._cur_req_id += 1
        return None if next_req_id is None else "{}{}-0000-0000-0000-{}".format(
            self._reqid_connection_part,
            "{:04}".format(next_req_id%10000),
            "{:012}".format(next_req_id))

    @staticmethod
    def _log_request(request):
        # log the request

        headers_descr = "\n".join(
            f"> {h_name}: {h_value!r}"
            for h_name, h_value in request.header_items())

        data = request.data
        if data is None:
            logger.error(
                "request %s %s\n%s",
                request.get_method(), request.get_full_url(), headers_descr)
        else:
            logger.error(
                "request %s %s\n%s\n data: %s",
                request.get_method(), request.get_full_url(), headers_descr, data)

    @staticmethod
    def _log_response(response, req_path):
        # log the response

        headers_descr = "\n".join(
            f"< {h_name}: {h_value}"
            for h_name, h_value in response.getheaders())

        logger.error(
            "%s %s <- %s\n%s\n%s",
            response._method, req_path, response.code, headers_descr, response.data)
